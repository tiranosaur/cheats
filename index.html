<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="jquery.js"></script>
    <style>
        h4 {
            text-align: center;
            margin-bottom: 10px;
            margin-top: 10px;
        }

        .accordeon {
            border: 10px solid #fff;
            box-shadow: 0 0 10px grey;
            margin: 5px;
            margin-bottom: 10px
        }

        .acc-head {
            font-size: 12px;
            text-align: center;
            padding: 5px 5px;
            background: rgba(192, 192, 192, 0.37);
            cursor: pointer;
            border: 1px solid white;
        }

        .acc-body {
            padding: 5px;
            margin-bottom: 2px;
            display: none;
            width: 60%;
            margin-left: 20%;
        }

        .explain {
            font-size: 20px;
            margin: 10px 10px;
            color: #770707;
        }

        .example {
            font-size: 20px;
            margin: 10px 10px;
        }

        .simple {
            font-size: 22px;
            margin: 10px 10px;
            color: #3b4b21;
        }
    </style>
</head>
<body>
<div>
    <div class="accordeon">

    </div>
</div>

<script>
    $(document).ready(function () {
        fill();
        $('.accordeon .acc-head').on('click', accClick);
    });

    function accClick() {
        $('.accordeon .acc-body').not($(this).next()).slideUp(300);
        $(this).next().slideToggle(300);
    }

    function fill() {
        let accordeon = document.getElementsByClassName("accordeon").item(0)
        for (const category of data) {
            accordeon.innerHTML += `<h4>${category.name}</h4>`
            for (const info of category.data) {
                accordeon.innerHTML += `
                    <div class="acc-head">${info.name}</div>
                    <div class="acc-body">
                        <p class="explain">${info.explain}</p>
                        <p class="example"> ${info.example}</p>
                        <p class="simple">${info.simple}</p>
                    </div>
                `
            }
        }
    }

    data = [
        {
            "name": "Порождающие (Сreational)",
            "data": [
                {
                    "name": "Простая фабрика (Simple Factory)",
                    "explain": "Фабрика — это объект для создания других объектов. Формально фабрика — это функция или метод, который возвращает объекты изменяющегося прототипа или класса из некоторого вызова метода, который считается «новым».",
                    "example": "Пример из жизни: Представьте, что вам надо построить дом, и вам нужны двери. Было бы глупо каждый раз, когда вам нужны двери, надевать вашу столярную форму и начинать делать дверь. Вместо этого вы делаете её на фабрике.",
                    "simple": "Простыми словами: Простая фабрика генерирует экземпляр для клиента, не раскрывая никакой логики."
                },
                {
                    "name": "Фабричный метод (Fabric Method)",
                    "explain": "Фабричный метод — порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы неспецифические классы и манипулировать абстрактными объектами на более высоком уровне.",
                    "example": "Пример из жизни: Рассмотрим пример с менеджером по найму. Невозможно одному человеку провести собеседования со всеми кандидатами на все вакансии. В зависимости от вакансии он должен распределить этапы собеседования между разными людьми.",
                    "simple": "Простыми словами: Генерирует экземпляр для клиента, не раскрывая никакой логики. Создает объект через статик функцию. Менеджер предоставляет способ делегирования логики создания экземпляра дочерним классам."
                },
                {
                    "name": "Абстрактная фабрика (Abstract Factory)",
                    "explain": "Абстрактная фабрика — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс.",
                    "example": "Пример из жизни: Расширим наш пример про двери из простой фабрики. В зависимости от ваших нужд вам понадобится деревянная дверь из одного магазина, железная дверь — из другого или пластиковая — из третьего. Кроме того, вам понадобится соответствующий специалист: столяр для деревянной двери, сварщик для железной двери и так далее. Как вы можете заметить, тут есть зависимость между дверьми.",
                    "simple": "Простыми словами: Фабрика фабрик. Фабрика, которая группирует индивидуальные, но связанные/зависимые фабрики без указания их конкретных классов."
                },
                {
                    "name": "Строитель (Builder)",
                    "explain": "Строитель — порождающий шаблон проектирования, который предоставляет способ создания составного объекта. Предназначен для решения проблемы антипаттерна «Телескопический конструктор».",
                    "example": "Пример из жизни: Представьте, что вы пришли в McDonalds и заказали конкретный продукт, например, БигМак, и вам готовят его без лишних вопросов. Это пример простой фабрики. Но есть случаи, когда логика создания может включать в себя больше шагов. Например, вы хотите индивидуальный сэндвич в Subway: у вас есть несколько вариантов того, как он будет сделан. Какой хлеб вы хотите? Какие соусы использовать? Какой сыр? В таких случаях на помощь приходит шаблон «Строитель».",
                    "simple": "Простыми словами: Шаблон позволяет вам создавать различные виды объекта, избегая засорения конструктора. Он полезен, когда может быть несколько видов объекта или когда необходимо множество шагов, связанных с его созданием."
                },
                {
                    "name": "Прототип (Prototype)",
                    "explain": "Задаёт виды создаваемых объектов с помощью экземпляра-прототипа и создаёт новые объекты путём копирования этого прототипа. Он позволяет уйти от реализации и позволяет следовать принципу «программирование через интерфейсы». В качестве возвращающего типа указывается интерфейс/абстрактный класс на вершине иерархии, а классы-наследники могут подставить туда наследника, реализующего этот тип.",
                    "example": "Пример из жизни: Помните Долли? Овечка, которая была клонирована. Не будем углубляться, главное — это то, что здесь все вращается вокруг клонирования.",
                    "simple": "Простыми словами: Прототип создает объект, основанный на существующем объекте при помощи клонирования."
                },
                {
                    "name": "Одиночка (Singleton)",
                    "explain": "Одиночка — порождающий шаблон проектирования, гарантирующий, что в однопроцессном приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру.",
                    "example": "Пример из жизни: В стране одновременно может быть только один президент. Один и тот же президент должен действовать, когда того требуют обстоятельства. Президент здесь является одиночкой.",
                    "simple": "Простыми словами: Обеспечивает тот факт, что создаваемый объект является единственным объектом своего класса."
                }
            ]
        },
        {
            "name": "Поведенческие (Behavioral)",
            "data": [
                {
                    "name": "Цепочка обязанностей (Chain of Responsibility)",
                    "explain": "Цепочка обязанностей— поведенческий шаблон проектирования предназначенный для организации в системе уровней ответственности.",
                    "example": "Пример из жизни: например, у вас есть три платежных метода (A, B и C), настроенных на вашем банковском счёте. На каждом лежит разное количество денег. На A есть 100 долларов, на B есть 300 долларов и на C — 1000 долларов. Предпочтение отдается в следующем порядке: A, B и C. Вы пытаетесь заказать что-то, что стоит 210 долларов. Используя цепочку обязанностей, первым на возможность оплаты будет проверен метод А, и в случае успеха пройдет оплата и цепь разорвется. Если нет, то запрос перейдет к методу B для аналогичной проверки. Здесь A, B и C — это звенья цепи, а все явление — цепочка обязанностей.",
                    "simple": "Простыми словами: цепочка обязанностей помогает строить цепочки объектов. Запрос входит с одного конца и проходит через каждый объект, пока не найдет подходящий обработчик."
                },
                {
                    "name": "Команда (Command)",
                    "explain": "Команда — поведенческий шаблон проектирования, используемый при объектно-ориентированном программировании, представляющий действие. Объект команды заключает в себе само действие и его параметры.",
                    "example": "Пример из жизни: Типичный пример: вы заказываете еду в ресторане. Вы (т.е. Client) просите официанта (например, Invoker) принести еду (то есть Command), а официант просто переправляет запрос шеф-повару (то есть Receiver), который знает, что и как готовить. Другим примером может быть то, что вы (Client) включаете (Command) телевизор (Receiver) с помощью пульта дистанционного управления (Invoker).",
                    "simple": "Простыми словами: Позволяет вам инкапсулировать действия в объекты. Основная идея, стоящая за шаблоном — это предоставление средств, для разделения клиента и получателя."
                },
                {
                    "name": "Итератор (Iterator)",
                    "explain": "Итератор — поведенческий шаблон проектирования. Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого из агрегированных объектов.",
                    "example": "Пример из жизни: Старый радионабор будет хорошим предметом итератора, где пользователь может начать искать сигнал на каком-то канале и затем использовать кнопки переключения на следующий и предыдущий канал для перехода между соответствующими каналами. Или используем пример телевизора, где вы можете нажимать кнопки следующего или предыдущего канала для перехода через последовательные каналы, или, иными словами, они предоставляют интерфейс для итерирования между соответствующими каналами, песнями или радиостанциями.",
                    "simple": "Простыми словами: Представляет способ доступа к элементам объекта без показа базового представления."
                },
                {
                    "name": "Посредник (Mediator)",
                    "explain": "Посредник — поведенческий шаблон проектирования, обеспечивающий взаимодействие множества объектов, формируя при этом слабую связанность, и избавляя объекты от необходимости явно ссылаться друг на друга.",
                    "example": "Пример из жизни: Общим примером будет, когда вы говорите с кем-то по мобильнику, то между вами и собеседником находится мобильный оператор. То есть сигнал передаётся через него, а не напрямую. Аналогично, в авиадиспетчерской все авиадиспетчеры направляют сообщения диспетчеру, а не напрямую друг к другу.",
                    "simple": "Простыми словами: Посредник добавляет третью часть-посредника для управления взаимодействием между двумя объектами."
                },
                {
                    "name": "Хранитель (Memento)",
                    "explain": "Хранитель — поведенческий шаблон проектирования, предназначенный для реализации механизма, позволяющего сохранять и восстанавливать прежнее состояние объекта без нарушения принципа инкапсуляции.",
                    "example": "Пример из жизни: Очень просто. Вы когда-нибудь использовали калькулятор? Если да, то помните кнопку сохранения (M+). Она используется для сохранения текущего состояния. Позже вы можете восстановить это состояние с помощью кнопки MC. Текущая кнопка может быть ассоциирована с caretaker (опекуном), тогда как сохранённое значение — с хранителем.",
                    "simple": "Простыми словами: Хранитель фиксирует и восстанавливает внутреннее состояние объекта, не нарушая инкапсуляции."
                },
                {
                    "name": "Наблюдатель (Observer)",
                    "explain": "Наблюдатель — поведенческий шаблон проектирования, использующий отношение «один ко многим». Он позволяет одному объекту посылать оповещения о событии другим объектам.",
                    "example": "Пример из жизни: Процесс найма сотрудников — лучший пример этого паттерна. Здесь несколько соискателей просят уведомить их, когда будет открыта вакансия. По мере того как только вакансия открывается, соискатели получают уведомление.",
                    "simple": "Простыми словами: Определяет зависимость один ко многим между объектами так, что когда один объект изменяет состояние, все зависимые получают уведомление и обновляются автоматически."
                },
                {
                    "name": "Посетитель (Visitor)",
                    "explain": "Посетитель — поведенческий шаблон проектирования, описывающий операцию, которая выполняется над объектами других классов. При изменении visitor нет необходимости изменять обслуживаемые классы.",
                    "example": "Пример из жизни: Рассмотрим туризм. Туристы — это посетители, а различные места, которые они хотят посетить — элементы. Например, вы посетили Дубай и решили посетить здание Бурдж-Халифа, аквариум и аквапарк, пустынное сафари и острова Пальм. Порядок посещения каждого из этих мест составляет шаблон посещения.",
                    "simple": "Простыми словами: Посетитель позволяет добавлять операции для объектов, не изменяя их."
                },
                {
                    "name": "Стратегия (Strategy)",
                    "explain": "Стратегия — поведенческий шаблон проектирования, предназначенный для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости.",
                    "example": "Пример из жизни: Вы можете использовать пример из сортировки. Вам нужно отсортировать данные. Для небольшого количества данных пузырьковая сортировка будет лучшей (менее затратной). Для больших данных быстрая сортировка будет лучшей (с точки зрения производительности). Так что все эти стратегии будут применены к данным в зависимости от размера данных.",
                    "simple": "Простыми словами: Позволяет менять логику выполнения в зависимости от ситуации."
                },
                {
                    "name": "Состояние (State)",
                    "explain": "Состояние — поведенческий шаблон проектирования, предназначенный для управления состоянием объекта и позволяющий изменять его поведение при изменении его внутреннего состояния.",
                    "example": "Пример из жизни: Рассмотрим пример с радиоприёмником. В радиоприемнике есть несколько состояний: включено, выключено, радио АМ, радио ФМ и так далее. Радиоприемник будет вести себя по-разному в каждом из этих состояний. Например, если приемник включен, то он может переключаться между состояниями AM и FM. Но если он выключен, то переключаться между состояниями не получится.",
                    "simple": "Простыми словами: Позволяет объекту изменять свое поведение при изменении его состояния."
                },
                {
                    "name": "Шаблонный метод (Template Method)",
                    "explain": "Шаблонный метод — поведенческий шаблон проектирования, определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуры.",
                    "example": "Пример из жизни: Рассмотрим строительство дома. Шаблонный метод будет подготавливать основы: установка фундамента, возведение стен и крыши. Но предоставит варианты для выбора материалов, типа стен и т. д.",
                    "simple": "Простыми словами: Определяет основу алгоритма, позволяя наследникам изменять шаги, не меняя общей структуры."
                }
            ],
        },
        {
            "name": "Структурные (Structural)",
            "data": [
                {
                    "name": "Адаптер (Adapter)",
                    "explain": "Адаптер — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс.",
                    "example": "Пример из жизни: Например, в разных странах используются разные вилки и розетки. Для того чтобы решить эту проблему, мы используем специальные устройства, называемые адаптерами, которые позволяют вилке с одной формой разъёма подключаться к розетке другой формы.",
                    "simple": "Простыми словами: Адаптер оборачивает несовместимые объекты и делает их совместимыми друг с другом."
                },
                {
                    "name": "Мост (Bridge)",
                    "explain": "Мост — структурный шаблон проектирования, использующий инкапсуляцию, агрегирование и может использовать наследование для того, чтобы разделить ответственность между классами.",
                    "example": "Пример из жизни: В случае с веб-сайтами, вам, возможно, придётся переключаться между разными темами. Что вы делаете? Предпочли бы вы создать отдельную копию каждой страницы для каждой темы или просто будете иметь одну структуру страницы и применять темы динамически? Мост позволяет вам сделать последнее.",
                    "simple": "Простыми словами: Мост предпочитает композицию над наследованием. Подробности реализации передаются другому объекту."
                },
                {
                    "name": "Компоновщик (Composite)",
                    "explain": "Компоновщик — структурный шаблон проектирования, предназначенный для объединения объектов в древовидную структуру для представления иерархии от частного к целому.",
                    "example": "Пример из жизни: Организация, которая состоит из сотрудников. Каждый сотрудник имеет общее свойство — выполнять свою работу, и могут быть подчиненные. Таким образом, иерархия строится из нескольких сотрудников.",
                    "simple": "Простыми словами: Компоновщик позволяет работать с отдельными объектами в едином стиле."
                },
                {
                    "name": "Декоратор (Decorator)",
                    "explain": "Декоратор — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту.",
                    "example": "Пример из жизни: Представьте автосервис. Вы проходите техническое обслуживание автомобиля. Есть базовая стоимость, к которой могут быть добавлены дополнительные опции: замена масла, замена тормозных колодок, мойка и так далее. Каждый новый сервис будет добавляться к общей стоимости и так далее.",
                    "simple": "Простыми словами: Декоратор динамически изменяет поведение объекта во время выполнения."
                },
                {
                    "name": "Фасад (Facade)",
                    "explain": "Фасад — структурный шаблон проектирования, обеспечивающий простой интерфейс к сложной системе классов, библиотеке или фреймворку.",
                    "example": "Пример из жизни: Вам не нужно знать, что происходит внутри системы, чтобы включить компьютер. Всё, что вам нужно, это просто нажать кнопку включения, остальное будет сделано для вас.",
                    "simple": "Простыми словами: Фасад предоставляет простой интерфейс к сложной системе."
                },
                {
                    "name": "Приспособленец (Flyweight)",
                    "explain": "Приспособленец — структурный шаблон проектирования, при котором обеспечивается эффективное использование памяти путём совместного использования большого количества мелких объектов.",
                    "example": "Пример из жизни: В реальном мире чай в уличном чайном ларьке готовится в большой ёмкости. Затем он наливается в разные стаканчики, и каждому покупателю подаётся индивидуально.",
                    "simple": "Простыми словами: Приспособленец помогает создавать тысячи или миллионы объектов, экономя память путём совместного использования их общего состояния."
                },
                {
                    "name": "Заместитель (Proxy)",
                    "explain": "Заместитель — структурный шаблон проектирования, предоставляющий объект, который контролирует доступ к другому объекту.",
                    "example": "Пример из жизни: Когда вы работаете в офисе, вам нужен пропуск для доступа в здание. Здесь, имея пропуск, вы не идёте к начальнику охраны каждый раз, когда вам нужно войти. Пропуск является прокси объектом для начальника охраны.",
                    "simple": "Простыми словами: Прокси предоставляет замену другому объекту для управления доступом к нему."
                }
            ]
        }
    ];
</script>
</body>
</html>
