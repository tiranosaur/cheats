<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Cheat</title>
    <script src="jquery.js"></script>
    <style>
        h4 {
            text-align: center;
            margin-bottom: 10px;
            margin-top: 10px;
        }

        .accordeon {
            border: 10px solid #fff;
            box-shadow: 0 0 10px grey;
            margin: 5px;
            margin-bottom: 10px
        }

        .acc-head {
            font-size: 12px;
            text-align: center;
            padding: 5px 5px;
            background: rgba(192, 192, 192, 0.37);
            cursor: pointer;
            border: 1px solid white;
        }

        .acc-body {
            padding: 5px;
            margin-bottom: 2px;
            display: none;
            width: 60%;
            margin-left: 20%;
        }

        .content {
            margin-left: 20%;
        }

        @media (max-width: 768px) {
            .acc-body {
                width: 100%;
                margin-left: 0;
            }

            .content {
                width: 100%;
            }
        }

        .explain {
            font-size: 20px;
            margin: 10px 10px;
            color: #770707;
        }

        .example {
            font-size: 20px;
            margin: 10px 10px;
        }

        .simple {
            font-size: 22px;
            margin: 10px 10px;
            color: #3b4b21;
        }

        .mono-habr {
            width: 80%;
        }
    </style>
</head>
<body>
<main>
    <div class="accordeon"></div>
    <h3><a href="isolation.html" target="_blank">Db isolation</a></h3>
    <h3><a href="functional.html" target="_blank">functional</a></h3>
    <h3><a href="body.png" target="_blank">HTTP body</a></h3>
    <h3><a href="oAuth2.html" target="_blank">oAuth2</a></h3>
    <h3><a href="async.html" target="_blank">Async</a></h3>
    <h3><a href="golang/index.html" target="_blank">GOLANG</a></h3>
    <hr>
    <div class="content"><img src="sql.jpg"></div>
    <div class="content"><img src="kafka.png"></div>
</main>
<footer>
    <div><a href="https://dzen.ru/a/YKJ99EP6Y0aFqFC1">microservices pattern</a></div>
</footer>
<script>
    $(document).ready(function () {
        fill();
        $('.accordeon .acc-head').on('click', accClick);
        $('.accordeon .acc-body').on('click', accClick);
    });

    function accClick() {
        $('.accordeon .acc-body').not($(this).next()).slideUp(300);
        $(this).next().slideToggle(300);
    }

    function fill() {
        let accordeon = document.getElementsByClassName("accordeon").item(0)
        for (const category of data) {
            accordeon.innerHTML += `<h4>${category.name}</h4>`
            for (const info of category.data) {
                var html = `
                    <div class="acc-head">${info.name}</div>
                    <div class="acc-body">
                        <p class="simple">${info.simple}</p>
                        <p class="example"> ${info.example}</p>
                        <p class="explain">${info.explain}</p>`;

                if (info.java != null && info.java != "") {
                    html += `
                            <a href="${info.java}" target="_blank">JAVA</a>
                        <iframe src="${info.java}" width="100%"></iframe>`
                }
                html += "</div>"
                accordeon.innerHTML += html;
            }
        }
    }

    data = [
        {
            "name": "Порождающие (Creational)",
            "data": [
                {
                    "name": "Simple Factory (Простая фабрика)",
                    "explain": "Объект для создания других объектов. Функция или метод, возвращающий объекты определённого класса.",
                    "example": "Для создания дверей заказываем их на фабрике вместо изготовления самостоятельно.",
                    "simple": "Генерирует экземпляр для клиента, скрывая логику.",
                    "java": "src/main/java/org/example/gof/creational/SimpleFactory.java"
                },
                {
                    "name": "Fabric Method (Фабричный метод)",
                    "explain": "Интерфейс для создания экземпляров класса, делегирующий создание объектов подклассам.",
                    "example": "Менеджер делегирует собеседования для различных вакансий соответствующим людям.",
                    "simple": "Создаёт объект через static функцию, делегируя логику создания подклассам.",
                    "java": "src/main/java/org/example/gof/creational/FabricMethod.java"
                },
                {
                    "name": "Abstract Factory (Абстрактная фабрика)",
                    "explain": "Интерфейс для создания семейств взаимосвязанных объектов без указания их конкретных классов.",
                    "example": "Покупаем разные двери и нанимаем соответствующих специалистов для их установки.",
                    "simple": "Фабрика фабрик, группирующая взаимосвязанные фабрики.",
                    "java": "src/main/java/org/example/gof/creational/AbstractFactory.java"
                },
                {
                    "name": "Builder (Строитель)",
                    "explain": "Способ создания составного объекта, решающий проблему «телескопического конструктора».",
                    "example": "Создание индивидуального сэндвича в Subway с выбором ингредиентов.",
                    "simple": "Позволяет создавать различные виды объекта, избегая засорения конструктора.",
                    "java": "src/main/java/org/example/gof/creational/Builder.java"
                },
                {
                    "name": "Prototype (Прототип)",
                    "explain": "Создание новых объектов путём копирования существующего экземпляра-прототипа.",
                    "example": "Пример из жизни: Помните Долли? Овечка, которая была клонирована. Не будем углубляться, главное — это то, что здесь все вращается вокруг клонирования.",
                    "simple": "Создаёт объект на основе существующего путём клонирования.",
                    "java": "src/main/java/org/example/gof/creational/Prototype.java"
                },
                {
                    "name": "Singleton (Одиночка)",
                    "explain": "Гарантирует, что в приложении будет единственный экземпляр класса с глобальной точкой доступа.",
                    "example": "В стране может быть только один президент.",
                    "simple": "Создаёт единственный экземпляр класса.",
                    "java": "src/main/java/org/example/gof/creational/Singleton.java"
                }
            ]
        },
        {
            "name": "Поведенческие (Behavioral)",
            "data": [
                {
                    "name": "Chain of Responsibility (Цепочка обязанностей)",
                    "explain": "Организация уровней ответственности в системе.",
                    "example": "Платёжные методы проверяются последовательно до успешной оплаты.",
                    "simple": "Запрос проходит через цепочку объектов, пока не найдёт подходящий обработчик.",
                    "java": "src/main/java/org/example/gof/behavior/ChainOfResponsibility.java"
                },
                {
                    "name": "Command (Команда)",
                    "explain": "Объект команды заключает всебе само действие и его параметры.",
                    "example": "Заказ еды в ресторане, где официант передаёт запрос шеф-повару.",
                    "simple": "Инкапсулирует действия в объекты, разделяя клиента и получателя.",
                    "java": "src/main/java/org/example/gof/behavior/CommandPattern.java"
                },
                {
                    "name": "Iterator (Итератор)",
                    "explain": "Объект для последовательного доступа к элементам агрегата без их описания.",
                    "example": "Переключение каналов на телевизоре.",
                    "simple": "Способ доступа к элементам объекта без показа базового представления.",
                    "java": "src/main/java/org/example/gof/behavior/Iterator.java"
                },
                {
                    "name": "Mediator (Посредник)",
                    "explain": "Обеспечивает взаимодействие объектов, избавляя их от необходимости явно ссылаться друг на друга.",
                    "example": "Мобильный оператор передаёт сигнал между абонентами.",
                    "simple": "Управляет взаимодействием между объектами через посредника. Шаблон посредник подразумевает добавление стороннего объекта (посредника) для управления взаимодействием между двумя объектами (коллегами).",
                    "java": "src/main/java/org/example/gof/behavior/Mediator.java"
                },
                {
                    "name": "Memento (Хранитель)",
                    "explain": "Сохраняет и восстанавливает внутреннее состояние объекта без нарушения инкапсуляции.",
                    "example": "Калькулятор сохраняет последнюю операцию в памяти.",
                    "simple": "Фиксирует и хранит текущее состояние объекта для восстановления.",
                    "java": "src/main/java/org/example/gof/behavior/Memento.java"
                },
                {
                    "name": "Observer (Наблюдатель)",
                    "explain": "Создаёт механизм оповещения объекта об изменении состояния других объектов.",
                    "example": "Соискатели получают уведомления о новых вакансиях.",
                    "simple": "Определяет зависимость между объектами для уведомления об изменениях.",
                    "java": "src/main/java/org/example/gof/behavior/ObserverPattern.java"
                },
                {
                    "name": "Visitor (Посетитель)",
                    "explain": "Операция, выполняемая над объектами других классов, без их изменения.",
                    "example": "Туристы посещают различные места в Дубае.",
                    "simple": "Добавляет операции для объектов без их модифицирования.",
                    "java": "src/main/java/org/example/gof/behavior/VisitorPattern.java"
                },
                {
                    "name": "Strategy (Стратегия)",
                    "explain": "Определяет семейство алгоритмов, позволяя выбирать и изменять алгоритм в зависимости от ситуации.",
                    "example": "Использование пузырьковой сортировки для небольших данных и быстрой для больших.",
                    "simple": "Позволяет переключаться между алгоритмами в зависимости от ситуации.",
                    "java": "src/main/java/org/example/gof/behavior/StrategyPattern.java"
                },
                {
                    "name": "State (Состояние)",
                    "explain": "Изменяет поведение объекта в зависимости от его состояния.",
                    "example": "Кисть в графическом редакторе меняет цвет в зависимости от настройки.",
                    "simple": "Меняет поведение класса при изменении состояния.",
                    "java": "src/main/java/org/example/gof/behavior/StatePattern.java"
                },
                {
                    "name": "Template Method (Шаблонный метод)",
                    "explain": "Определяет основу алгоритма, позволяя наследникам переопределять некоторые шаги.",
                    "example": "Пример из жизни: Допустим, вы собрались строить дома. Этапы будут такими: 1. Подготовка фундамента. 2. Возведение стен. 3. Настил крыши. 4. Настил перекрытий. Порядок этапов никогда не меняется. Вы не настелите крышу до возведения стен и т. д. Но каждый этап модифицируется: стены, например, можно возвести из дерева, кирпича или газобетона.",
                    "simple": "Определяет алгоритм с возможностью изменения некоторых шагов наследниками.",
                    "java": "src/main/java/org/example/gof/behavior/TemplateMethodPattern.java"
                }
            ]
        },
        {
            "name": "Структурные (Structural)",
            "data": [
                {
                    "name": "Adapter (Адаптер)",
                    "explain": "Организация использования функций объекта через специально созданный интерфейс.",
                    "example": "Карт-ридер для переноса изображений с карты памяти на компьютер.",
                    "simple": "Оборачивает несовместимые объекты в адаптер для их совместимости.",
                    "java": "src/main/java/org/example/gof/structural/Adapter.java"
                },
                {
                    "name": "Bridge (Мост)",
                    "explain": "Разделяет абстракцию и реализацию для их независимого изменения.",
                    "example": "Позволяет менять темы на сайте без создания копий страниц.",
                    "simple": "Предпочитает композицию над наследованием, передавая детали реализации другому объекту.",
                    "java": "src/main/java/org/example/gof/structural/Bridge.java"
                },
                {
                    "name": "Composite (Компоновщик)",
                    "explain": "Объединяет объекты в древовидную структуру для представления иерархии от частного к целому.",
                    "example": "Организация с сотрудниками, имеющими общие свойства.",
                    "simple": "Позволяет работать с индивидуальными объектами в едином стиле.",
                    "java": "src/main/java/org/example/gof/structural/CompositePattern.java"
                },
                {
                    "name": "Decorator (Декоратор)",
                    "explain": "Динамическое подключение дополнительного поведения к объекту.",
                    "example": "Автосервис, где сумма в счете за услуги складывается из отдельных цен.",
                    "simple": "Динамически изменяет поведение объекта во время работы. Позволяет динамически расширять функцию существующего объекта, не изменяя его внутренности.",
                    "java": "src/main/java/org/example/gof/structural/DecoratorPattern.java"
                },
                {
                    "name": "Facade (Фасад)",
                    "explain": "Скрывает сложность системы, предоставляя единый интерфейс.",
                    "example": "Включение компьютера нажатием кнопки.",
                    "simple": "Предоставляет упрощённый интерфейс для сложной системы.",
                    "java": "src/main/java/org/example/gof/structural/Facade.java"
                },
                {
                    "name": "Flyweight (Приспособленец)",
                    "explain": "Минимизирует использование памяти путем разделения ресурсов.",
                    "example": "Чай в уличном ларьке готовится в большой емкости для экономии ресурсов.",
                    "simple": "Делит ресурсы между похожими объектами для минимизации использования памяти.",
                    "java": "src/main/java/org/example/gof/structural/Flyweigh.java"
                },
                {
                    "name": "Proxy (Заместитель)",
                    "explain": "Объект, контролирующий доступ к другому объекту.",
                    "example": "Использование карты доступа.",
                    "simple": "Контролирует доступ к другому объекту, выполняя функцию контейнера.",
                    "java": "src/main/java/org/example/gof/structural/Proxy.java"
                }
            ]
        },
        {
            "name": "Паттерны декомпозиции на микросервисы",
            "data": [
                {
                    "name": "Decompose By Business Capability (Разбиение по бизнес-возможностям)",
                    "simple": "Определение бизнес-возможностей приложения и создание по одному микросервису на каждую из них. Бизнес-возможности представляют собой функции, которые будут доступны пользователям при работе с приложением.",
                    "example": "",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/dbbc.png'/>",
                    "java": ""
                },
                {
                    "name": "Decompose By Subdomain (Разбиение по поддоменам)",
                    "simple": "Разбивает всю модель предметной области (домен) на поддомены. У каждого поддомена своя модель данных, область действия которой принято называть ограниченным контекстом (Bounded Context). Каждый микросервис будет разрабатываться внутри этого ограниченного контекста. Основная задача при использовании DDD-подхода — подобрать поддомены и границы между ними так, чтобы они были максимально независимы друг от друга.",
                    "example": "<p>При разбиении по бизнес-возможностям могут появиться так называемые «божественные классы» (God Classes) — сущности, которые будут общими для нескольких микросервисов. Как правило, их очень сложно разделить.</p><p>Например, в приложении для интернет-магазина такой сущностью может стать заказ. В приведенном выше примере он используется сразу в нескольких сервисах: создание заказов (Orders Creation), доставка заказов (Orders Delivery), оповещения о заказах (Orders Alerts), предзаказы (Preorders).</p><p>Чтобы избежать появления God Classes, можно использовать альтернативный шаблон разложения на микросервисы — разбиение по поддоменам. Он основан на концепциях предметно-ориентированного проектирования (Domain-Driven Design, DDD).</p><p>Если вернуться к примеру с интернет-магазином, то все, что связано с заказами, можно рассматривать в рамках поддомена «Заказы» (Orders Subdomain) и именно внутри этого поддомена создавать микросервис по управлению заказами (Orders Service). Таким образом, можно сократить число микросервисов по сравнению с декомпозицией на основе бизнес-возможностей. В нашем сильно упрощенном примере четыре микросервиса были преобразованы в один.</p>",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/dbc.png'/>",
                    "java": ""
                },
            ]
        },
        {
            "name": "Паттерны рефакторинга для перехода на микросервисы",
            "data": [
                {
                    "name": "Strangler (Душитель)",
                    "simple": "Этот паттерн предназначен для постепенного перехода к микросервисной архитектуре от монолитного приложения. Старая функциональность заменяется новыми сервисами, и последние используются после завершения работы, в то время как первые вытесняются.",
                    "example": "Фасадный интерфейс играет важную роль в процессе, когда сервисы, отделившись от монолита, выходят во внешний мир. Таким образом, клиенты узнают о новых сервисах за фасадом, и это заслоняет старую систему.",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/strangler.png'/>",
                    "java": ""
                },
                {
                    "name": "Anti-Corruption Layer (Уровень защиты от повреждений)",
                    "simple": "предназначен для изолирования различных подсистем путем размещения между ними дополнительного уровня, который может быть реализован как компонент приложения или независимая служба. Этот уровень связывает две подсистемы, позволяя им оставаться максимально независимыми друг от друга. Он содержит всю логику, необходимую для передачи данных в обе стороны: при взаимодействии с каждой из подсистем используется именно ее модель данных.",
                    "example": "При переводе Legacy-приложений на микросервисы рефакторинг некоторых подсистем может оказаться очень долгим либо вовсе невозможным. Но взаимодействовать с устаревшими подсистемами все равно нужно, несмотря на то, что в них, возможно, используются не самые современные технологии в части построения API, схем данных и так далее.",
                    "explain": "Похож на mediator(посредник)<img class='mono-habr' src='src/main/java/org/example/monolith/img/acl.png'/>",
                    "java": ""
                },
            ]
        },
        {
            "name": "Паттерны управления данными в микросервисной архитектуре",
            "data": [
                {
                    "name": "Database Per Service (База данных на сервис)",
                    "simple": "Основная рекомендация при переходе на микросервисы — предоставить каждому сервису собственное хранилище данных, чтобы не было сильных зависимостей на уровне данных. При этом имеется в виду именно логическое разделение данных, то есть микросервисы могут совместно использовать одну и ту же физическую базу данных, но в ней они должны взаимодействовать с отдельной схемой, коллекцией или таблицей.",
                    "example": "<p>Повышает автономность микросервисов и уменьшает связь между командами, разрабатывающими отдельные сервисы.</p><p>У паттерна есть и недостатки: усложняется обмен данными между сервисами и предоставление транзакционных гарантий ACID. Паттерн не стоит применять в небольших приложениях — он предназначен для крупномасштабных проектов с большим числом микросервисов, где каждой команде требуется полное владение ресурсами для повышения скорости разработки и лучшего масштабирования.</p><p>Паттерну Database Per Service часто противопоставляют другой шаблон — <b>Shared Database («Разделяемая база данных»)</b>. По сути, он представляет собой антипаттерн и подразумевает использование одного хранилища данных несколькими микросервисами. Его допускается использовать на начальных стадиях миграции на микросервисную архитектуру или в очень небольших приложениях, разрабатываемых одной командой (2–3 микросервиса).</p>",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/dpservice.png'/>",
                    "java": ""
                },
                {
                    "name": "API Composition (API-композиция)",
                    "simple": "Этот шаблон является одним из возможных вариантов получения данных из нескольких сервисов после применения к ним паттерна Database Per Service. Он предлагает создать отдельное API, которое будет вызывать необходимые сервисы, владеющие данными, и выполнять соединение полученных от них результатов в памяти. Паттерн можно рассматривать как вариант использования другого шаблона — API Gateway",
                    "example": "API Composition — это самый простой способ получения данных из нескольких источников, но он может привести к неэффективному объединению больших наборов данных в памяти. Альтернативным решением является следующий шаблон CQRS.",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/api_composition.png'/>",
                    "java": ""
                },
                {
                    "name": "<b>CQRS</b> Command Query Responsibility Segregation,  (Разделение команд и запросов)",
                    "simple": "CQRS (Command Query Responsibility Segregation) — это архитектурный паттерн, который разделяет операции чтения (query) и записи (command) в системе. Основная идея заключается в том, чтобы создать отдельные модели для чтения и записи данных, что позволяет оптимизировать каждую из них в соответствии с их требованиями и задачами.",
                    "example": "Паттерн CQRS обеспечивает высокую доступность данных, независимое масштабирование систем чтения/записи и более быстрое чтение данных в микросервисах, управляемых событиями. Однако его использование увеличивает сложность системы и приводит к слабой согласованности данных. ",
                    "explain": "<img style='width: 49%' src='src/main/java/org/example/monolith/img/cqrs1.png'/><img style='width: 49%' src='src/main/java/org/example/monolith/img/cqrs2.png'/>",
                    "java": ""
                },
                {
                    "name": "Event Sourcing (Поиск событий)",
                    "simple": "состояние системы сохраняется как последовательность неизменяемых событий. Вместо хранения текущего состояния системы напрямую, сохраняются все события, которые привели систему к этому состоянию.",
                    "example": "В традиционных базах данных объект с текущим состоянием сохраняется напрямую. При использовании шаблона Event Sourcing вместо объектов сохраняются события, изменяющие их состояния. Итоговое состояние объекта можно получить путем повторной обработки серии событий, пришедших за определенное время. Различные службы могут воспроизводить события из хранилища событий, чтобы вычислить соответствующее состояние своих хранилищ данных. Для реализации хранилища событий обычно применяется шаблон CQRS.",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/event_sourcing.png'/>",
                    "java": ""
                },
                {
                    "name": "Saga (Сага)",
                    "simple": "предназначен для управления распределенными транзакциями в микросервисной архитектуре, где применение традиционного протокола двухфазной фиксации транзакций (Two-phase commit protocol, 2PC) становится трудноосуществимым.",
                    "example": "При использовании паттерна каждая локальная транзакция обновляет данные в хранилище в рамках одного микросервиса и публикует событие или сообщение, которые, в свою очередь, запускают следующую локальную транзакцию и так далее. Если локальная транзакция завершается с ошибкой, выполняется серия компенсирующих транзакций, которые отменяют изменения предыдущих транзакций.",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/saga.png'/>",
                    "java": ""
                },
            ]
        },
        {
            "name": "Паттерны коммуникации микросервисов",
            "data": [
                {
                    "name": "API Gateway (API-шлюз)",
                    "simple": "Этот паттерн основан на применении шлюза, который находится между клиентским приложением и микросервисами, обеспечивая единую точку входа для клиента.",
                    "example": "Применение паттерна сокращает число вызовов, обеспечивает независимость клиента от протоколов, используемых в сервисах: REST, AMQP, gRPC и так далее, обеспечивает централизованное управление сквозной функциональностью. Однако шлюз может стать единой точкой отказа, требует тщательного мониторинга и при отсутствии масштабирования бывает узким местом системы",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/api_gateway.png'/>",
                    "java": ""
                },
                {
                    "name": "Backends for Frontends, BFF (Бэкенды для фронтендов)",
                    "simple": "Этот паттерн является вариантом реализации шаблона API Gateway. Он также обеспечивает дополнительный уровень между микросервисами и клиентами, но вместо одной точки входа вводит несколько шлюзов для каждого типа клиента: Web, Mobile, Desktop и так далее.",
                    "example": "",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/bff.png'/>",
                    "java": ""
                },
            ]
        },
        {
            "name": "Паттерны построения пользовательского интерфейса",
            "data": [
                {
                    "name": "Client-Side UI Composition (Сборка пользовательского интерфейса на стороне клиента)",
                    "simple": "При использовании этого шаблона разметка HTML создается и обновляется непосредственно в браузере. Каждый экран/страница пользовательского интерфейса разбивается на фрагменты, данные для которых получают различные микросервисы. Каждый такой фрагмент, по сути, представляет собой мини-приложение, которое может отображать и обновлять свою разметку независимо от остальной части страницы.",
                    "example": "Многие современные фреймворки, например AngularJS и ReactJS, помогают в реализации этого шаблона. Они используют принцип одностраничных приложений (Single-Page Application, SPA), позволяя обновлять отдельную область экрана, а не всю страницу целиком.",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/client_side_ui.png'/>",
                    "java": ""
                },
                {
                    "name": "Server-Side Page Fragment Composition (Сборка фрагментов страниц на стороне сервера)",
                    "simple": "При использовании этого шаблона сборка фрагментов пользовательского интерфейса происходит на сервере, а клиентская часть получает уже полностью собранную страницу, благодаря чему достигается более высокая скорость загрузки.",
                    "example": "",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/client_side_page.png'/>",
                    "java": ""
                },

            ]
        },
        {
            "name": "Паттерны обнаружения сервисов в микросервисной архитектуре",
            "data": [
                {
                    "name": "Service Registry (Ключевой элемент паттерна)",
                    "simple": "база данных с информацией о расположении сервисных экземпляров. Когда экземпляры запускаются и останавливаются, информация в реестре обновляется. Но взаимодействовать с реестром сервисов можно двумя путями, которые и легли в основу описанных ниже шаблонов.",
                    "example": "",
                    "explain": "",
                    "java": ""
                },
                {
                    "name": "Client-Side Service Discovery (Обнаружение сервисов на стороне клиента)",
                    "simple": "Поиск и регистрация сервисов на стороне клиента.",
                    "example": "<p>Первый способ обнаружения сервисов — на стороне клиента. В этом случае сервисы и их клиенты напрямую взаимодействуют с реестром. Последовательность шагов следующая:</p><ol><li>Экземпляр сервиса обращается к API реестра, чтобы зарегистри­ровать свое сетевое местоположение. Он также может предоставить URL-адрес для проверки своей работоспособности (Health Check), который будет использоваться для продления срока его регистрации в реестре.</li>    <li>Клиент самостоятельно обращается к реестру сервисов, чтобы получить список экземпляров сервисов. Для улучшения производительности клиент может кэшировать экземпляры сервиса.</li>    <li>Клиент использует алгоритм балансировки нагрузки, циклический или случайный, чтобы выбрать конкретный экземпляр сервиса и отправить ему запрос.</li>    </ol><p>Ключевое преимущество обнаружения сервисов на стороне клиента — его независимость от используемой платформы развертывания. Например, если часть ваших сервисов развернута на K8s, а остальные работают в устаревшей среде, то обнаружение на уровне приложения будет лучшим вариантом, так как серверное решение на базе Kubernetes не будет совместимо со всеми сервисами.</p><p>К недостаткам подхода можно отнести необходимость использования различных клиентских библиотек для каждого языка программирования, а иногда и фреймворка. Кроме этого, на вашу команду ложится дополнительная нагрузка по настройке и обслуживанию реестра сервисов.</p>",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/client_side_service_discovery.png'/>",
                    "java": ""
                },
                {
                    "name": "Server-Side Service Discovery (Обнаружение сервисов на стороне сервера)",
                    "simple": "Поиск и регистрация сервисов на стороне сервера.",
                    "example": "<p>Второй способ обнаружения сервисов — на стороне сервера. В этом случае за регистрацию, обнаружение сервисов и маршрутизацию запросов отвечает инфраструктура развертывания. Последовательность шагов следующая:</p><ol>    <li>Регистратор, который обычно является частью платформы развертывания, прописывает все экземпляры сервисов в реестре сервисов. По каждому экземпляру сохраняется DNS-имя и виртуальный IP-адрес (VIP).</li>    <li>Вместо того чтобы обращаться к реестру напрямую, клиент делает запрос по DNS-имени сервиса. Запрос поступает в маршрутизатор, являющийся частью платформы развертывания.</li>    <li>Маршрутизатор обращается к реестру сервисов для получения сетевого расположения экземпляров нужного сервиса.</li>    <li>Маршрутизатор применяет балансировку нагрузки, чтобы выбрать конкретный экземпляр сервиса и отправить ему запрос.</li>    </ol><p>Все современные платформы развертывания, включая Docker, Kubernetes и другие, как правило, имеют встроенный реестр и механизмы обнаружения сервисов.</p><p>Основное преимущество паттерна состоит в том, что всеми аспектами обнаружения сервисов занимается сама платформа. Дополнительный код на стороне клиента или сервисов не требуется. Благодаря этому достигается независимость от используемых в приложении языков программирования и фреймворков.</p><p>Недостатком паттерна является невозможность его применения к сервисам, которые развернуты вне основной платформы, реализующей механизмы обнаружения. Несмо­тря на это ограничение, рекомендуется использовать обнаружение сервисов на стороне сервера всюду, где это осуществимо.</p>",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/server_side_discovery.png'/>",
                    "java": ""
                },
            ]
        },
        {
            "name": "Паттерны развертывания микросервисов",
            "data": [
                {
                    "name": "Blue-Green Deployment ()",
                    "simple": "",
                    "example": "<p>Паттерн позволяет выполнить развертывание новых версий сервисов максимально незаметно для пользователей, сократив время простоя до минимума. Это достигается за счет запуска двух идентичных производственных сред — условно синего и зеленого цвета. Предположим, что синий — это существующий активный экземпляр, а зеленый — это новая версия приложения, развернутая параллельно с ним.</p><p>В любой момент времени только одна из сред является активной, и именно она обслуживает весь производственный трафик. После успешного развертывания новой версии — с прохождением всех тестов и так далее — трафик переключается на нее. В случае ошибок всегда можно вернуться к предыдущей версии.</p>",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/blue_green.png'/>",
                    "java": ""
                },
            ]
        },
        {
            "name": "Паттерны повышения отказоустойчивости",
            "data": [
                {
                    "name": "Circuit Breaker (Автоматический выключатель)",
                    "simple": "",
                    "example": "<p>При взаимодействии микросервисов не исключены ситуации, когда по какой-то причине один из сервисов перестает отвечать. Справиться с временными сбоями (медленное сетевое соединение, временная недоступность и так далее) помогают повторные вызовы. Однако при более серьезных сбоях, вызванных полным отказом сервиса, повторные вызовы будут лишь расходовать ресурсы.</p><p>В таких случаях рекомендуется использовать шаблон Circuit Breaker. Микросервис будет запрашивать другой микросервис через Proxy-сервер. Он подсчитывает количество недавних сбоев и на основе него определяет, разрешать ли выполнение последующих вызовов или немедленно возвращать исключение.</p><p>Proxy-сервер может находиться в трех состояниях:</p><ol>    <li>Closed. Идет передача запросов между сервисами и подсчет количества сбоев. Если число сбоев за заданный интервал времени превышает пороговое значение, выключатель Proxy-сервера переводится в состояние Open.</li>    <li>Open. Запросы от исходного сервиса немедленно возвращаются с ошибкой. По истечении заданного тайм-аута выключатель переводится в состояние Half-Open.</li>    <li>Half-Open. Выключатель пропускает ограниченное количество запросов от исходного сервиса и подсчитывает число успешных запросов. Если необходимое количество достигнуто, выключатель переходит в состояние Closed, если нет — возвращается в статус Open.</li></ol><p>Использование шаблона повышает отказоустойчивость и предотвращает каскадные сбои, но требует тщательной настройки и мониторинга.</p>",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/circut_breaket.png'/>",
                    "java": ""
                },
                {
                    "name": "Bulkhead (Переборка)",
                    "simple": "Шаблон позволяет разделить ресурсы, чтобы гарантировать, что ресурсы, используемые для вызова одного сервиса, не влияют на ресурсы, используемые для вызова другого сервиса.",
                    "example": "<p>Свое название паттерн получил благодаря переборкам, используемым в судостроении: они защищают корабль от полного затопления в случае повреждения отдельных его частей. Так же и в архитектуре приложения: переборки изолируют элементы приложения в пулы, чтобы в случае сбоя одного из них остальные продолжали функционировать.</p><p>Еще один вариант использования шаблона — назначение каждому клиенту сервиса отдельного экземпляра сервиса. В таком случае, если один из клиентов сделает слишком много запросов, перегрузив свой экземпляр, другие клиенты смогут продолжить работу.</p><p>Использование этого паттерна предотвращает каскадные сбои и изолирует критически важные ресурсы, но приводит к дополнительной сложности и менее эффективному использованию ресурсов.</p>",
                    "explain": "<img style='width: 49%' src='src/main/java/org/example/monolith/img/bulk1.png'/><img style='width: 49%' src='src/main/java/org/example/monolith/img/bulk2.png'/>",
                    "java": ""
                },
                {
                    "name": "Rate limiting",
                    "simple": "это механизм контроля трафика, который ограничивает количество запросов, поступающих в систему за определенный период времени. Этот подход используется для предотвращения перегрузки серверов, защиты от DoS-атак и обеспечения справедливого распределения ресурсов среди пользователей.",
                    "example": "<ol>    <li>Fixed Window (Фиксированное окно) - В этом методе запросы считаются в пределах фиксированных временных интервалов (например, каждую минуту или час). Если количество запросов превышает лимит в текущем окне, дальнейшие запросы блокируются до следующего окна.</li>    <li>Sliding Window (Скользящее окно) - Этот метод обеспечивает более плавное ограничение запросов. В скользящем окне каждый новый запрос сдвигает окно, и запросы считаются в пределах текущего интервала времени.</li>    <li>Token Bucket (Ведро с токенами) - В этом методе у пользователя есть «ведро», наполненное токенами. Каждый запрос «потребляет» один токен. Токены добавляются в ведро с фиксированной скоростью. Если ведро пустое, запросы отклоняются.</li>    <li>Leaky Bucket (Протекающее ведро) - Метод, похожий на ведро с токенами, но с постоянной скоростью утечки токенов. Запросы обрабатываются по мере поступления, если есть токены, иначе они отклоняются.</li></ol>",
                    "explain": "<img class='mono-habr' src=''/>",
                    "java": ""
                },
            ]
        },
        {
            "name": "Паттерны мониторинга микросервисов",
            "data": [
                {
                    "name": "Log Aggregation (Агрегация логов)",
                    "simple": "Паттерн Log Aggregation предлагает использовать централизованную службу ведения логов, которая будет собирать логи от каждого экземпляра сервиса. Это предоставит пользователям единую точку для поиска, анализа логов и настройки предупреждений, которые будут запускаться при появлении в них определенных сообщений.",
                    "example": "",
                    "explain": "<img class='mono-habr' src=''/>",
                    "java": ""
                },
                {
                    "name": "Distributed Tracing (Распределенная трассировка)",
                    "simple": "предлагает назначать каждому внешнему запросу уникальный идентификатор (TraceId), который будет передаваться всем сервисам, участвующим в обработке запроса, и фиксироваться в журналах. Это позволит разработчикам видеть, как обрабатывается отдельный запрос, путем поиска в агрегированных журналах его внешнего идентификатора.",
                    "example": "В микросервисной архитектуре для выполнения клиентских запросов может потребоваться работа нескольких взаимосвязанных микросервисов. Каждый сервис обрабатывает запрос путем выполнения одной или нескольких операций, включая обращение к базе данных, публикацию сообщений и так далее. С увеличением числа сервисов становится все сложнее отследить место возникновения ошибок.",
                    "explain": "<img class='mono-habr' src=''/>",
                    "java": ""
                },
                {
                    "name": "Health Check",
                    "simple": "предлагает определить для каждого endpoint, которую можно использовать для проверки работоспособности, например /health. Этот API должен проверять статус хоста, подключение к другим сервисам, инфраструктуре и любую иную бизнес-логику. Клиент — служба мониторинга, реестр служб или балансировщик нагрузки — будет периодически обращаться к конечной точке для проверки работоспособности экземпляра сервиса.",
                    "example": "",
                    "explain": "<img class='mono-habr' src=''/>",
                    "java": ""
                },
            ]
        },
        {
            "name": "Прочие паттерны проектирования микросервисов",
            "data": [
                {
                    "name": "Ambassador",
                    "simple": "",
                    "example": "<p>Приложениям и сервисам часто требуются общие функции, относящиеся к мониторингу, ведению журналов, настройкам безопасности, сетевым службам и так далее. Однако в микросервисной архитектуре отдельные сервисы могут быть построены с помощью различных языков и технологий — следовательно, они могут иметь свои зависимости и требовать определенных языковых библиотек. Паттерн Ambassador предлагает помещать клиентские фреймворки и библиотеки для решения периферийных задач внутрь вспомогательного сервиса, выступающего в роли Proxy между клиентским приложением или основным сервисом и прочими частями системы.</p><p>Применение паттерна Ambassador позволяет:</p><ol>    <li>Унифицировать обращение клиентских приложений к общим задачам независимо от используемого языка и фреймворка.</li>    <li>Решать периферийные задачи, не затрагивая основную функциональность, в том числе за счет передачи разработки отдельным специализированным командам. Это полезно, например, при необходимости централизованного управления сетевыми вызовами и функциями безопасности — во избежание дублирования сложного кода на каждом компоненте отдельно.</li>    <li>Добавлять новую функциональность в Legacy-приложения, которые тяжело поддаются рефакторингу.</li></ol><p>Так как добавление Proxy пусть и незначительно, но увеличивает сетевые задержки, шаблон Ambassador не рекомендуется использовать, когда время задержки критично. Также паттерн лучше не применять в случаях, когда можно обойтись стандартной клиентской библиотекой — например, если используется всего один язык или нет возможности выделить общие периферийные задачи.</p><p>Развернуть Proxy можно как демон или службу. Если основной сервис является контейнерным, Proxy также разворачивается как отдельный контейнер на том же хосте, для этой цели используется другой паттерн — Sidecar.</p>",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/ambasador.png'/>",
                    "java": ""
                },
                {
                    "name": "Sidecar (Коляска)",
                    "simple": "",
                    "example": "<p>Паттерн Sidecar предлагает помещать периферийные задачи, связанные с мониторингом, безопасностью, отказоустойчивостью и так далее, в отдельный компонент и развертывать его внутри собственного процесса или контейнера. Так обеспечивается однородный интерфейс для сервисов основного приложения, которые могут быть написаны на разных языках.</p><p>Sidecar не обязательно является частью приложения, но связан с ним: для каждого экземпляра приложения рядом развертывается экземпляр Sidecar. Sidecar имеет тот же жизненный цикл, что и основное приложение.</p><p>Преимуществами паттерна являются независимость вспомогательного компонента от платформы основного приложения, возможность их доступа к одним и тем же ресурсам, минимизация задержек из-за их близкого расположения и возможность независимого обновления. К недостаткам можно отнести накладные расходы на создание дополнительного компонента. Шаблон не рекомендуется использовать для небольших приложений, а также в тех случаях, когда можно обойтись библиотеками и стандартными механизмами расширений.</p>\n",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/sidecar.png'/>",
                    "java": ""
                },
                {
                    "name": "Consumer-Driven Contract Testing (Тестирование контрактов, ориентированных на потребителя)",
                    "simple": "",
                    "example": "<p>Это один из стилей тестирования, который рекомендуют использовать в крупномасштабных проектах, где несколько команд работают над различными сервисами. Суть паттерна в том, что набор автоматизированных тестов для каждого сервиса (Provider Microservice) пишется разработчиками других сервисов (Consumer Microservice), вызывающих проверяемый сервис. Каждый такой набор тестов является контрактом, проверяющим, соответствует ли сервис провайдера ожиданиям потребителя. Сами тесты включают в себя запрос и ожидаемый ответ.</p><p>Паттерн Consumer-Driven Contract Testing увеличивает автономность команд и позволяет своевременно обнаруживать изменения в сервисах, написанных другими командами. Но его применение может потребовать дополнительной работы по интеграции тестов, так как команды могут пользоваться различными инструментами тестирования.</p>",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/cdct.png'/>",
                    "java": ""
                },
                {
                    "name": "External Configuration (Внешняя конфигурация)",
                    "simple": "",
                    "example": " в приложениях корпоративного уровня рекомендуется использовать шаблон External Configuration, предлагающий хранить все конфигурации во внешнем хранилище. В качестве такого хранилища может выступать облачная служба хранения, база данных или другая система.",
                    "explain": "<img class='mono-habr' src='src/main/java/org/example/monolith/img/config.png'/>",
                    "java": ""
                },
            ]
        }
    ];
</script>
</body>
</html>
